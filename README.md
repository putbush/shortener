# URL Shortener

Сервис для создания коротких ссылок из длинных URL-адресов. Работает быстро, безопасно и надежно.

## Что умеет

- Создавать короткие коды для любых ссылок
- Считать количество переходов по каждой ссылке
- Работать с пользовательскими алиасами (своими кодами)
- Устанавливать срок жизни ссылок
- Кешировать популярные ссылки для быстрого доступа

## Быстрый запуск

```bash
git clone <адрес-репозитория>
cd shortener
cp .env.example .env
docker-compose up --build
```

Откроется на http://localhost:3000

## Как это работает

### Создание коротких кодов

Когда вы создаете ссылку:
1. Система сохраняет её в базу данных с пустым кодом
2. Получает автоматически сгенерированный ID записи
3. Генерирует код на основе этого ID
4. Обновляет запись с новым кодом

**Как генерируется код (реальная реализация):**
- Создается запись в базе с пустым кодом, получаем уникальный ID
- ID конвертируется в Base62 (0-9, a-z, A-Z) - это сжимает число
- Если код короче 8 символов, добавляются случайные символы в начало
- Пример: ID=1000 → Base62="G8" → дополняется до "ZxK9mfG8" (8 символов)
- Обновляется запись в базе с финальным кодом

**Решение коллизий:**
- ID из базы гарантированно уникален (автоинкремент PostgreSQL)
- Base62 преобразование сохраняет уникальность
- Случайные символы только дополняют длину, не влияют на уникальность
- Вся операция выполняется в транзакции - либо успех, либо откат

**Обработка пользовательских алиасов:**
- Проверяется уникальность на уровне базы данных
- При дублировании выбрасывается ConflictException
- Никаких повторных попыток - пользователь должен выбрать другой алиас

### Переходы по ссылкам

Когда кто-то кликает короткую ссылку:
1. Система ищет URL сначала в Redis кеше
2. Если не найдена - запрашивает из основной базы PostgreSQL  
3. Перенаправляет пользователя немедленно
4. Отправляет асинхронное событие для обновления счетчика

**Асинхронная аналитика (реальная реализация):**
- Используется встроенный EventEmitter2 из NestJS
- При переходе генерируется событие `EVENTS.LINK_VISITED`
- LinkAnalyticsListener подписан на это событие с флагом `{ async: true }`
- Счетчик обновляется в отдельной задаче: `visits: { increment: 1 }`
- Если обновление упадет с ошибкой, пользователь об этом не узнает

**Race Conditions при создании алиасов:**

*Проблема:* Два пользователя одновременно пытаются создать ссылку с алиасом "my-link"

*Как это решено:*
1. В схеме базы данных поле `code` имеет ограничение `@unique()`
2. PostgreSQL гарантирует уникальность на уровне индекса
3. Первый запрос успешно создает запись
4. Второй запрос получает ошибку `P2002` (UNIQUE_VIOLATION)
5. `handlePrismaError` перехватывает ошибку и возвращает `ConflictException`
6. Пользователь получает HTTP 409 с сообщением "Code 'my-link' is already taken"

*Почему это надежно:*
- Проверка происходит на уровне базы данных, не в приложении
- Невозможно обойти даже при высоких нагрузках
- Нет окна времени между проверкой и вставкой
- Работает корректно при любом количестве одновременных запросов

### Кеширование

Система умно использует память:
- Популярные ссылки сохраняются в Redis
- Непопулярные ссылки читаются из основной базы
- Кеш автоматически обновляется
- Это ускоряет работу в несколько раз

**Стратегия кеширования:**

*Пороговое кеширование:*
- В кеш попадают ссылки с количеством посещений >= CACHE_VISITS_THRESHOLD (по умолчанию 5)
- Проверка происходит после каждого запроса к базе данных
- Если `link.visits >= VISITS_THRESHOLD` - ссылка добавляется в Redis

*Время жизни кеша:*
- Обычные ссылки: CACHE_DEFAULT_EXPIRATION_HOURS * 3600 секунд (по умолчанию 6 часов)
- Ссылки с истечением: `Math.floor((expiresAt - now) / 1000)` секунд
- Redis автоматически удалит ключ по истечении TTL

*Алгоритм работы:*
1. `resolveFromCache(code)` - проверяем Redis
2. Если найдено - отдаем немедленно + отправляем событие аналитики
3. Если нет - `resolveFromDatabase(code)`  
4. Проверяем срок истечения ссылки, удаляем просроченные
5. Если `visits >= threshold` - кешируем с TTL
6. Возвращаем результат

*Особенности:*
- Кеширование происходит асинхронно (`void this.redis.set()`)
- Не блокирует ответ пользователю
- Просроченные ссылки удаляются из базы автоматически

## Безопасность

### Защита от атак

**Строгая проверка данных:**
- Принимаются только URL, алиас и время жизни
- Любые дополнительные поля отклоняются
- Алиас может содержать только буквы, цифры, дефис и подчеркивание
- URL проверяется на корректность

**Защита от подбора кодов:**
- Коды длинные и сложные (миллиарды вариантов)
- Содержат случайные части
- Практически невозможно угадать чужую ссылку

**Защита базы данных:**
- Используются безопасные запросы через Prisma
- Невозможны SQL-инъекции
- Все операции выполняются в транзакциях

### Защита от одновременных запросов

Если два пользователя одновременно пытаются создать одинаковый алиас:
- База данных отклонит дубликат
- Пользователь получит понятную ошибку
- Данные останутся целыми

## Важные решения

### Скорость важнее точности

Пользователь должен попасть на сайт мгновенно. Поэтому:
- Редирект происходит сразу
- Счетчик кликов обновляется в фоне
- Если счетчик не обновится - не страшно, главное что пользователь перешел

### Кешируем только популярное

Не храним в памяти все ссылки подряд:
- В кеше только ссылки с 5+ переходами
- Остальные читаем из базы (тоже быстро)
- Экономим память Redis

### Выбор в пользу простоты

Используем простые решения:
- События через встроенный EventEmitter
- При росте нагрузки легко поменять на очереди сообщений
- Код остается понятным

### Безопасность через базу данных

Защищаемся правильно:
- Уникальность алиасов гарантирует PostgreSQL
- Валидацию делает Zod с strict режимом
- Коды генерируются криптографически стойко

## API

### Создать короткую ссылку

**POST /links**

Отправьте JSON:
```json
{
  "url": "https://example.com",
  "alias": "my-code",     // необязательно
  "ttl": 24               // часы, необязательно
}
```

Получите ответ:
- **200** - ссылка создана
- **400** - неправильные данные  
- **409** - такой алиас уже существует

### Перейти по ссылке

**GET /:код**

Что происходит:
- Редирект на оригинальную ссылку
- Увеличение счетчика посещений
- Если код не найден - ошибка 404

## Тестирование

Проект частично покрыт базовыми тестами:

**Unit-тесты** - проверяют ключевую бизнес-логику

**Интеграционные тесты** - проверяют API эндпоинты

**Запуск тестов:**
- Unit тесты: `pnpm test`
- Интеграционные тесты: `pnpm test:integration`

## Развертывание

### Локальная разработка

1. Установите Node.js 18+
2. Установите зависимости: `pnpm install`
3. Скопируйте настройки: `cp .env.example .env`
4. Примените миграции: `npx prisma migrate dev`
5. Запустите: `pnpm run start:dev`

### Docker

Проект готов для контейнеризации:
- Многоэтапная сборка для оптимизации размера
- Отдельные контейнеры для приложения, базы, кеша
- Автоматические миграции при запуске

### Настройки окружения

Основные переменные в `.env`:
- `DATABASE_URL` - подключение к PostgreSQL
- `REDIS_HOST`, `REDIS_PORT` - подключение к Redis  
- `PORT` - порт приложения
- `CACHE_TTL_SECONDS` - время жизни кеша
- `CACHE_THRESHOLD` - когда начинать кешировать

---

*Проект готов к использованию в реальных условиях. Архитектура позволяет легко масштабировать и улучшать систему по мере роста нагрузки.*

